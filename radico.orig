#!/bin/bash



# Global configuration
AI_FEATURES_ENABLED=false
SCRIPT_NAME="$(basename "$0")"
LOGGING_ENABLED=true
LOG_FILE="radico.LOG"
COLOR_PROFILE_SET=false
LOG_FILE_SET=false

# Color profile system - OPTION to choose color schemes
declare -A COLOR_PROFILES

# Default color profile
COLOR_PROFILES["default"]="RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' NC='\033[0m'"

# Professional color profile (muted)
COLOR_PROFILES["professional"]="RED='\033[0;91m' GREEN='\033[0;92m' YELLOW='\033[0;93m' BLUE='\033[0;94m' PURPLE='\033[0;95m' CYAN='\033[0;96m' NC='\033[0m'"

# High contrast color profile
COLOR_PROFILES["high-contrast"]="RED='\033[1;31m' GREEN='\033[1;32m' YELLOW='\033[1;33m' BLUE='\033[1;34m' PURPLE='\033[1;35m' CYAN='\033[1;36m' NC='\033[0m'"

# Monochrome profile
COLOR_PROFILES["monochrome"]="RED='\033[1;37m' GREEN='\033[0;37m' YELLOW='\033[1;37m' BLUE='\033[0;37m' PURPLE='\033[1;37m' CYAN='\033[0;37m' NC='\033[0m'"

# Dark theme optimized
COLOR_PROFILES["dark"]="RED='\033[0;196m' GREEN='\033[0;82m' YELLOW='\033[0;226m' BLUE='\033[0;75m' PURPLE='\033[0;135m' CYAN='\033[0;87m' NC='\033[0m'"

# Function to load user color profiles from common locations
load_user_color_profiles() {
    local profile_locations=(
        "$HOME/.config/radico/colors"
        "$HOME/.radico_colors"
        "$HOME/.config/terminal/colors"
        "$HOME/.local/share/color-schemes"
        "$HOME/.kde/share/apps/konsole"
        "$HOME/.config/konsole"
        "$HOME/.gnome-terminal/profiles"
    )
    
    for location in "${profile_locations[@]}"; do
        if [ -d "$location" ]; then
            for profile_file in "$location"/*.conf "$location"/*.colorscheme "$location"/*.profile; do
                if [ -f "$profile_file" ]; then
                    local profile_name
                    profile_name=$(basename "$profile_file" | sed 's/\.[^.]*$//')
                    parse_color_profile "$profile_file" "$profile_name"
                fi
            done
        fi
    done
}

# Function to parse color profile files
parse_color_profile() {
    local file="$1"
    local name="$2"
    local profile_name
    
    # Try to extract color values from various formats
    if grep -q "Color" "$file" 2>/dev/null; then
        # Basic color extraction (simplified)
        COLOR_PROFILES["$name"]="RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' NC='\033[0m'"
    fi
}

# Function to set color profile
set_color_profile() {
    local profile="$1"
    
    if [ -n "${COLOR_PROFILES[$profile]}" ]; then
        eval "${COLOR_PROFILES[$profile]}"
        echo -e "${GREEN}Color profile set to: $profile${NC}"
    else
        echo -e "${RED}Unknown color profile: $profile. Using default.${NC}"
        eval "${COLOR_PROFILES[default]}"
    fi
}

# Function to choose color profile
choose_color_profile() {
    echo -e "\n${CYAN}=== Color Profile Selection ===${NC}"
    echo -e "${YELLOW}Available color profiles:${NC}"
    local i=1
    local profile_list=()
    
    for profile in "${!COLOR_PROFILES[@]}"; do
        profile_list+=("$profile")
        echo -e "${BLUE}$i) $profile${NC}"
        ((i++))
    done
    
    echo -e "${BLUE}0) Skip color selection (use default)${NC}"
    echo -e ""
    echo -e "${CYAN}Choose a color profile (0-$((${#profile_list[@]}))): ${NC}"
    read -r choice
    
    if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -le "${#profile_list[@]}" ]; then
        local selected_profile="${profile_list[$((choice-1))]}"
        set_color_profile "$selected_profile"
        echo -e "${GREEN}Selected: $selected_profile${NC}"
    else
        set_color_profile "default"
        echo -e "${YELLOW}Using default color profile${NC}"
    fi
}

# Initialize color profiles
load_user_color_profiles

# Set default colors initially
eval "${COLOR_PROFILES[default]}"

# Function to display banner
show_banner() {
    echo -e "${CYAN}================================================${NC}"
    echo -e "${CYAN}    Connectivity Troubleshooter v2.0${NC}"
    echo -e "${CYAN}    Enhanced with AI-Powered Assistance${NC}"
    echo -e "${CYAN}================================================${NC}"
}

# Function to show usage information
show_usage() {
    echo -e "${BLUE}Usage:${NC}"
    echo -e "  $SCRIPT_NAME [OPTIONS]"
    echo -e ""
    echo -e "${BLUE}Options:${NC}"
    echo -e "  --ai-enabled     Enable AI troubleshooting features"
    echo -e "  --ai-help SERVICE QUERY   Get AI assistance"
    echo -e "  --color-profile PROFILE   Set color profile"
    echo -e "  --log-file FILENAME       Enable logging to specified file"
    echo -e "  --help, -h       Show this help message"
    echo -e ""
    echo -e "${BLUE}Color Profiles:${NC}"
    echo -e "  default         Standard terminal colors"
    echo -e "  professional    Muted professional colors"
    echo -e "  high-contrast   High contrast colors"
    echo -e "  monochrome      Grayscale colors"
    echo -e "  dark           Dark theme optimized"
    echo -e ""
    echo -e "${BLUE}AI Services:${NC}"
    echo -e "  openai          OpenAI GPT-4 (requires OPENAI_API_KEY)"
    echo -e "  anthropic       Anthropic Claude (requires ANTHROPIC_API_KEY)"
    echo -e "  perplexity      Perplexity AI (requires PERPLEXITY_API_KEY)"
    echo -e "  local           Local Ollama (requires ollama installation)"
    echo -e ""
    echo -e "${YELLOW}ðŸ“– For detailed usage examples and function reference, see NFO.md${NC}"
}

show_banner

# Detect OS
if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS=$NAME
    VERSION=$VERSION_ID
elif type lsb_release >/dev/null 2>&1; then
    OS=$(lsb_release -si)
    VERSION=$(lsb_release -sr)
elif [ -f /etc/redhat-release ]; then
    OS="Red Hat Enterprise Linux"
    VERSION=$(cat /etc/redhat-release | sed 's/.*release //' | sed 's/ .*//')
else
    OS=$(uname -s)
    VERSION=$(uname -r)
fi

echo -e "${BLUE}Detected OS:${NC} $OS $VERSION"

# Define required tools and their packages for different distributions
declare -A TOOLS_DEBIAN=(
    ["ip"]="iproute2"
    ["ifconfig"]="net-tools"
    ["ethtool"]="ethtool"
    ["mii-tool"]="net-tools"
    ["ping"]="iputils-ping"
    ["traceroute"]="traceroute"
    ["nslookup"]="dnsutils"
    ["dig"]="dnsutils"
    ["host"]="dnsutils"
    ["route"]="net-tools"
    ["tracepath"]="iputils-tracepath"
    ["mtr"]="mtr-tiny"
    ["ss"]="iproute2"
    ["netstat"]="net-tools"
    ["lspci"]="pciutils"
    ["lsusb"]="usbutils"
    ["iwconfig"]="wireless-tools"
    ["iw"]="iw"
    ["rfkill"]="rfkill"
    ["iwlist"]="wireless-tools"
    ["wpa_passphrase"]="wpasupplicant"
    ["wpa_supplicant"]="wpasupplicant"
    ["dhclient"]="isc-dhcp-client"
    ["hciconfig"]="bluez"
    ["bluetoothctl"]="bluez"
    ["hcitool"]="bluez"
    ["hcidump"]="bluez-hcidump"
    ["btmon"]="bluez"
    ["ufw"]="ufw"
    ["iptables"]="iptables"
    ["lsof"]="lsof"
    ["systemctl"]="systemd"
    ["journalctl"]="systemd"
)

declare -A TOOLS_REDHAT=(
    ["ip"]="iproute"
    ["ifconfig"]="net-tools"
    ["ethtool"]="ethtool"
    ["mii-tool"]="net-tools"
    ["ping"]="iputils"
    ["traceroute"]="traceroute"
    ["nslookup"]="bind-utils"
    ["dig"]="bind-utils"
    ["host"]="bind-utils"
    ["route"]="net-tools"
    ["tracepath"]="iputils"
    ["mtr"]="mtr"
    ["ss"]="iproute"
    ["netstat"]="net-tools"
    ["lspci"]="pciutils"
    ["lsusb"]="usbutils"
    ["iwconfig"]="wireless-tools"
    ["iw"]="iw"
    ["rfkill"]="rfkill"
    ["iwlist"]="wireless-tools"
    ["wpa_passphrase"]="wpa_supplicant"
    ["wpa_supplicant"]="wpa_supplicant"
    ["dhclient"]="dhcp-client"
    ["hciconfig"]="bluez-utils"
    ["bluetoothctl"]="bluez"
    ["hcitool"]="bluez-utils"
    ["hcidump"]="bluez-hcidump"
    ["btmon"]="bluez"
    ["ufw"]="ufw"
    ["iptables"]="iptables"
    ["lsof"]="lsof"
    ["systemctl"]="systemd"
    ["journalctl"]="systemd"
)

declare -A TOOLS_ARCH=(
    ["ip"]="iproute2"
    ["ifconfig"]="net-tools"
    ["ethtool"]="ethtool"
    ["mii-tool"]="net-tools"
    ["ping"]="iputils"
    ["traceroute"]="traceroute"
    ["nslookup"]="bind"
    ["dig"]="bind"
    ["host"]="bind"
    ["route"]="net-tools"
    ["tracepath"]="iputils"
    ["mtr"]="mtr"
    ["ss"]="iproute2"
    ["netstat"]="net-tools"
    ["lspci"]="pciutils"
    ["lsusb"]="usbutils"
    ["iwconfig"]="wireless_tools"
    ["iw"]="iw"
    ["rfkill"]="rfkill"
    ["iwlist"]="wireless_tools"
    ["wpa_passphrase"]="wpa_supplicant"
    ["wpa_supplicant"]="wpa_supplicant"
    ["dhclient"]="dhcpcd"
    ["hciconfig"]="bluez-utils"
    ["bluetoothctl"]="bluez"
    ["hcitool"]="bluez-utils"
    ["hcidump"]="bluez-hcidump"
    ["btmon"]="bluez"
    ["ufw"]="ufw"
    ["iptables"]="iptables"
    ["lsof"]="lsof"
    ["systemctl"]="systemd"
    ["journalctl"]="systemd"
)

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to get package manager and set tools array
get_package_info() {
    if command_exists apt-get; then
        PKG_MANAGER="apt-get"
        PKG_INSTALL="sudo apt-get install -y"
        PKG_CHECK="apt-cache"
        PKG_SATISFY="apt satisfy -s"
        TOOLS_REF="TOOLS_DEBIAN"
    elif command_exists yum; then
        PKG_MANAGER="yum"
        PKG_INSTALL="sudo yum install -y"
        PKG_CHECK="yum info"
        PKG_SATISFY="yum deplist"
        TOOLS_REF="TOOLS_REDHAT"
    elif command_exists dnf; then
        PKG_MANAGER="dnf"
        PKG_INSTALL="sudo dnf install -y"
        PKG_CHECK="dnf info"
        PKG_SATISFY="dnf repoquery --requires"
        TOOLS_REF="TOOLS_REDHAT"
    elif command_exists pacman; then
        PKG_MANAGER="pacman"
        PKG_INSTALL="sudo pacman -S --noconfirm"
        PKG_CHECK="pacman -Si"
        PKG_SATISFY="pacman -Si"
        TOOLS_REF="TOOLS_ARCH"
    elif command_exists zypper; then
        PKG_MANAGER="zypper"
        PKG_INSTALL="sudo zypper install -y"
        PKG_CHECK="zypper info"
        PKG_SATISFY="zypper what-requires"
        TOOLS_REF="TOOLS_REDHAT"
    else
        echo -e "${RED}Unknown package manager. Please install missing tools manually.${NC}"
        return 1
    fi
}

# Function to get tool package name
get_tool_package() {
    local tool="$1"
    case "$TOOLS_REF" in
        "TOOLS_DEBIAN")
            echo "${TOOLS_DEBIAN[$tool]}"
            ;;
        "TOOLS_REDHAT")
            echo "${TOOLS_REDHAT[$tool]}"
            ;;
        "TOOLS_ARCH")
            echo "${TOOLS_ARCH[$tool]}"
            ;;
    esac
}

# Check tools and collect missing ones
check_tools() {
    local missing_tools=()
    local missing_packages=()
    
    echo -e "\n${YELLOW}Checking required tools...${NC}"
    
    get_package_info
    
    # Get list of tools to check based on the detected OS
    local tools_to_check=()
    case "$TOOLS_REF" in
        "TOOLS_DEBIAN")
            tools_to_check=("${!TOOLS_DEBIAN[@]}")
            ;;
        "TOOLS_REDHAT")
            tools_to_check=("${!TOOLS_REDHAT[@]}")
            ;;
        "TOOLS_ARCH")
            tools_to_check=("${!TOOLS_ARCH[@]}")
            ;;
    esac
    
    for tool in "${tools_to_check[@]}"; do
        if command_exists "$tool"; then
            echo -e "${GREEN}âœ“${NC} $tool - installed"
        else
            echo -e "${RED}âœ—${NC} $tool - missing"
            missing_tools+=("$tool")
            missing_packages+=("$(get_tool_package "$tool")")
        fi
    done
    
    if [ ${#missing_tools[@]} -eq 0 ]; then
        echo -e "\n${GREEN}All required tools are installed!${NC}"
        return 0
    else
        echo -e "\n${RED}Missing tools:${NC} ${missing_tools[*]}"
        echo -e "${YELLOW}Required packages:${NC} ${missing_packages[*]}"
        
        # Remove duplicates from packages using associative array
        declare -A unique_pkgs
        for pkg in "${missing_packages[@]}"; do
            unique_pkgs["$pkg"]=1
        done
        local unique_packages=("${!unique_pkgs[@]}")
        
        # Check package availability and dependencies
        echo -e "\n${BLUE}Verifying package availability...${NC}"
        local verified_packages
        verified_packages=$(check_package_availability "${unique_packages[@]}")
        read -ra available_packages <<< "$verified_packages"
        
        if [ ${#available_packages[@]} -eq 0 ]; then
            echo -e "${RED}No packages available for installation. Check your repositories.${NC}"
            if [ "$AI_FEATURES_ENABLED" = true ]; then
                echo -e "${PURPLE}ðŸ’¡ AI Suggestion: Try asking AI for alternative solutions${NC}"
            fi
            return 1
        fi
        
        echo -e "\n${BLUE}Installation command for $PKG_MANAGER:${NC}"
        echo -e "${YELLOW}$PKG_INSTALL ${available_packages[*]}${NC}"
        
        echo -e "\n${YELLOW}Would you like to install the available packages now? (y/N)${NC}"
        read -r response
        
        if [[ "$response" =~ ^[Yy]$ ]]; then
            echo -e "${BLUE}Installing available packages...${NC}"
            if $PKG_INSTALL "${available_packages[@]}"; then
                echo -e "${GREEN}Installation completed successfully!${NC}"
                echo -e "${BLUE}Re-checking tools...${NC}"
                # Re-run tool check to verify installation
                check_tools
            else
                echo -e "${RED}Installation failed. Please check the errors above.${NC}"
                echo -e "${YELLOW}You may need to run with sudo privileges or check your package repositories.${NC}"
                if [ "$AI_FEATURES_ENABLED" = true ]; then
                    echo -e "${PURPLE}ðŸ’¡ AI Suggestion: Get help with installation errors${NC}"
                fi
                return 1
            fi
        else
            echo -e "${YELLOW}Skipping installation. Some commands may fail without required tools.${NC}"
            echo -e "${BLUE}To install manually, run:${NC}"
            echo -e "${YELLOW}$PKG_INSTALL ${available_packages[*]}${NC}"
            if [ "$AI_FEATURES_ENABLED" = true ]; then
                echo -e "${PURPLE}ðŸ’¡ AI Suggestion: Get help with manual installation${NC}"
            fi
            return 1
        fi
    fi
}

# Function to check package availability and dependencies
check_package_availability() {
    local packages=("$@")
    local available_packages=()
    local unavailable_packages=()
    local broken_deps=()
    
    echo -e "${YELLOW}Checking package availability and dependencies...${NC}"
    
    for pkg in "${packages[@]}"; do
        case "$PKG_MANAGER" in
            "apt-get")
                if $PKG_CHECK show "$pkg" >/dev/null 2>&1; then
                    echo -e "${GREEN}âœ“${NC} $pkg - available"
                    # Check if package satisfies dependencies
                    if ! $PKG_SATISFY "$pkg" >/dev/null 2>&1; then
                        echo -e "${YELLOW}âš ${NC} $pkg - has dependency issues"
                        broken_deps+=("$pkg")
                    fi
                    available_packages+=("$pkg")
                else
                    echo -e "${RED}âœ—${NC} $pkg - not available in repositories"
                    unavailable_packages+=("$pkg")
                fi
                ;;
            "yum"|"dnf")
                if $PKG_CHECK "$pkg" >/dev/null 2>&1; then
                    echo -e "${GREEN}âœ“${NC} $pkg - available"
                    available_packages+=("$pkg")
                else
                    echo -e "${RED}âœ—${NC} $pkg - not available in repositories"
                    unavailable_packages+=("$pkg")
                fi
                ;;
            "pacman")
                if $PKG_CHECK "$pkg" >/dev/null 2>&1; then
                    echo -e "${GREEN}âœ“${NC} $pkg - available"
                    available_packages+=("$pkg")
                else
                    echo -e "${RED}âœ—${NC} $pkg - not available in repositories"
                    unavailable_packages+=("$pkg")
                fi
                ;;
        esac
    done
    
    if [ ${#unavailable_packages[@]} -gt 0 ]; then
        echo -e "\n${RED}Unavailable packages:${NC} ${unavailable_packages[*]}"
        echo -e "${YELLOW}You may need to enable additional repositories or find alternative packages.${NC}"
    fi
    
    if [ ${#broken_deps[@]} -gt 0 ]; then
        echo -e "\n${YELLOW}Packages with dependency issues:${NC} ${broken_deps[*]}"
        echo -e "${BLUE}Attempting to resolve dependencies...${NC}"
        
        case "$PKG_MANAGER" in
            "apt-get")
                echo -e "${YELLOW}Running: sudo apt-get update && sudo apt-get -f install${NC}"
                if command_exists apt; then
                    echo -e "${YELLOW}You can also try: sudo apt --fix-broken install${NC}"
                fi
                ;;
            "yum")
                echo -e "${YELLOW}Running: sudo yum clean all && sudo yum update${NC}"
                ;;
            "dnf")
                echo -e "${YELLOW}Running: sudo dnf clean all && sudo dnf update${NC}"
                ;;
        esac
    fi
    
    echo "${available_packages[@]}"
}

# ============================================================================
# AI TROUBLESHOOTING MODULE
# ============================================================================

# AI Module Configuration
AI_MODULE_VERSION="1.0"
SUPPORTED_AI_SERVICES=("openai" "anthropic" "perplexity" "local")

# Function to check if AI features are available
check_ai_availability() {
    local available_services=()
    
    echo -e "${PURPLE}=== AI Module Status Check ===${NC}"
    
    # Check for required tools
    if ! command_exists curl; then
        echo -e "${RED}âœ—${NC} curl - required for API calls (install with: apt install curl)"
        return 1
    fi
    
    if ! command_exists jq; then
        echo -e "${YELLOW}âš ${NC} jq - recommended for JSON parsing (install with: apt install jq)"
    else
        echo -e "${GREEN}âœ“${NC} jq - available for JSON parsing"
    fi
    
    # Check API keys
    [ -n "$OPENAI_API_KEY" ] && available_services+=("openai") && echo -e "${GREEN}âœ“${NC} OpenAI API key detected"
    [ -n "$ANTHROPIC_API_KEY" ] && available_services+=("anthropic") && echo -e "${GREEN}âœ“${NC} Anthropic API key detected"
    [ -n "$PERPLEXITY_API_KEY" ] && available_services+=("perplexity") && echo -e "${GREEN}âœ“${NC} Perplexity API key detected"
    
    # Check local AI
    if command_exists ollama; then
        available_services+=("local")
        echo -e "${GREEN}âœ“${NC} Ollama detected for local AI"
    else
        echo -e "${YELLOW}âš ${NC} Ollama not found (install from: https://ollama.ai)"
    fi
    
    if [ ${#available_services[@]} -eq 0 ]; then
        echo -e "${RED}No AI services available. Set API keys or install Ollama.${NC}"
        return 1
    else
        echo -e "${GREEN}Available AI services: ${available_services[*]}${NC}"
        return 0
    fi
}

# Function to validate AI service
validate_ai_service() {
    local service="$1"
    local valid=false
    
    for supported in "${SUPPORTED_AI_SERVICES[@]}"; do
        if [ "$service" = "$supported" ]; then
            valid=true
            break
        fi
    done
    
    if [ "$valid" = false ]; then
        echo -e "${RED}Invalid AI service: $service${NC}"
        echo -e "${YELLOW}Supported services: ${SUPPORTED_AI_SERVICES[*]}${NC}"
        return 1
    fi
    
    return 0
}

# Function to call OpenAI API
call_openai_api() {
    local query="$1"
    
    if [ -z "$OPENAI_API_KEY" ]; then
        echo -e "${RED}OpenAI API key not found. Set OPENAI_API_KEY environment variable.${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}ðŸ¤– Querying OpenAI GPT-4...${NC}"
    
    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.openai.com/v1/chat/completions" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -H "Content-Type: application/json" \
        -d "{
            \"model\": \"gpt-4\",
            \"messages\": [
                {\"role\": \"system\", \"content\": \"You are a Linux network troubleshooting expert. Provide concise, actionable CLI-based solutions.\"},
                {\"role\": \"user\", \"content\": \"$query\"}
            ],
            \"max_tokens\": 800,
            \"temperature\": 0.3
        }")
    
    local http_code="${response##*$'\n'}"
    local json_response="${response%$'\n'*}"
    
    if [ "$http_code" = "200" ]; then
        if command_exists jq; then
            echo "$json_response" | jq -r '.choices[0].message.content' 2>/dev/null || echo "$json_response"
        else
            echo "$json_response"
        fi
    else
        echo -e "${RED}API Error (HTTP $http_code). Check your API key and quota.${NC}"
        return 1
    fi
}

# Function to call Anthropic Claude API
call_anthropic_api() {
    local query="$1"
    
    if [ -z "$ANTHROPIC_API_KEY" ]; then
        echo -e "${RED}Anthropic API key not found. Set ANTHROPIC_API_KEY environment variable.${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}ðŸ§  Querying Anthropic Claude...${NC}"
    
    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.anthropic.com/v1/messages" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "Content-Type: application/json" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"claude-3-sonnet-20240229\",
            \"max_tokens\": 800,
            \"system\": \"You are a Linux network troubleshooting expert. Provide concise, actionable CLI-based solutions.\",
            \"messages\": [{\"role\": \"user\", \"content\": \"$query\"}]
        }")
    
    local http_code="${response##*$'\n'}"
    local json_response="${response%$'\n'*}"
    
    if [ "$http_code" = "200" ]; then
        if command_exists jq; then
            echo "$json_response" | jq -r '.content[0].text' 2>/dev/null || echo "$json_response"
        else
            echo "$json_response"
        fi
    else
        echo -e "${RED}API Error (HTTP $http_code). Check your API key and quota.${NC}"
        return 1
    fi
}

# Function to call Perplexity API
call_perplexity_api() {
    local query="$1"
    
    if [ -z "$PERPLEXITY_API_KEY" ]; then
        echo -e "${RED}Perplexity API key not found. Set PERPLEXITY_API_KEY environment variable.${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}ðŸ” Querying Perplexity AI...${NC}"
    
    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.perplexity.ai/chat/completions" \
        -H "Authorization: Bearer $PERPLEXITY_API_KEY" \
        -H "Content-Type: application/json" \
        -d "{
            \"model\": \"llama-3.1-sonar-large-128k-online\",
            \"messages\": [
                {\"role\": \"system\", \"content\": \"You are a Linux network troubleshooting expert with access to current information. Provide concise, actionable CLI-based solutions.\"},
                {\"role\": \"user\", \"content\": \"$query\"}
            ],
            \"max_tokens\": 800,
            \"temperature\": 0.3
        }")
    
    local http_code="${response##*$'\n'}"
    local json_response="${response%$'\n'*}"
    
    if [ "$http_code" = "200" ]; then
        if command_exists jq; then
            echo "$json_response" | jq -r '.choices[0].message.content' 2>/dev/null || echo "$json_response"
        else
            echo "$json_response"
        fi
    else
        echo -e "${RED}API Error (HTTP $http_code). Check your API key and quota.${NC}"
        return 1
    fi
}

# Function to call local Ollama
call_local_ai() {
    local query="$1"
    
    if ! command_exists ollama; then
        echo -e "${RED}Ollama not installed. Install from: https://ollama.ai${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}ðŸ  Querying Local AI (Ollama)...${NC}"
    
    # Check if Ollama service is running
    if ! pgrep -x "ollama" > /dev/null; then
        echo -e "${YELLOW}Starting Ollama service...${NC}"
        ollama serve &
        sleep 3
    fi
    
    # Try different models in order of preference
    local models=("llama2" "codellama" "mistral")
    local model_found=false
    
    for model in "${models[@]}"; do
        if ollama list | grep -q "$model"; then
            echo -e "${GREEN}Using model: $model${NC}"
            ollama run "$model" "As a Linux network troubleshooting expert, help with this issue: $query" 2>/dev/null
            model_found=true
            break
        fi
    done
    
    if [ "$model_found" = false ]; then
        echo -e "${YELLOW}No models found. Installing llama2...${NC}"
        ollama pull llama2
        ollama run llama2 "As a Linux network troubleshooting expert, help with this issue: $query"
    fi
}

# Main AI dispatcher function
call_ai_api() {
    local query="$1"
    local service="$2"
    
    if [ -z "$query" ]; then
        echo -e "${RED}Error: Query is required${NC}"
        return 1
    fi
    
    if [ -z "$service" ]; then
        echo -e "${RED}Error: AI service is required${NC}"
        echo -e "${YELLOW}Available services: ${SUPPORTED_AI_SERVICES[*]}${NC}"
        return 1
    fi
    
    if ! validate_ai_service "$service"; then
        return 1
    fi
    
    echo -e "${BLUE}=== AI Troubleshooting Assistant v$AI_MODULE_VERSION ===${NC}"
    echo -e "${CYAN}Query: $query${NC}"
    echo -e "${CYAN}Service: $service${NC}"
    echo ""
    
    case "$service" in
        "openai")
            call_openai_api "$query"
            ;;
        "anthropic")
            call_anthropic_api "$query"
            ;;
        "perplexity")
            call_perplexity_api "$query"
            ;;
        "local")
            call_local_ai "$query"
            ;;
    esac
}

# Function to display AI help and setup instructions
show_ai_help() {
    echo -e "${PURPLE}=== AI Troubleshooting Module Help ===${NC}"
    echo -e ""
    echo -e "${BLUE}Available AI Services:${NC}"
    echo -e "${GREEN}1. OpenAI GPT-4${NC} - Most comprehensive responses"
    echo -e "   Setup: export OPENAI_API_KEY='your-api-key'"
    echo -e "   Get key: https://platform.openai.com/api-keys"
    echo -e ""
    echo -e "${GREEN}2. Anthropic Claude${NC} - Excellent technical analysis"
    echo -e "   Setup: export ANTHROPIC_API_KEY='your-api-key'"
    echo -e "   Get key: https://console.anthropic.com/"
    echo -e ""
    echo -e "${GREEN}3. Perplexity AI${NC} - Real-time web search + AI"
    echo -e "   Setup: export PERPLEXITY_API_KEY='your-api-key'"
    echo -e "   Get key: https://www.perplexity.ai/settings/api"
    echo -e ""
    echo -e "${GREEN}4. Local Ollama${NC} - Privacy-focused local AI"
    echo -e "   Setup: curl -fsSL https://ollama.ai/install.sh | sh"
    echo -e "   Then: ollama pull llama2"
    echo -e ""
    echo -e "${YELLOW}ðŸ“– For comprehensive usage examples and troubleshooting scenarios, see NFO.md${NC}"
}

# Function to ask user about AI features
prompt_ai_features() {
    if [ "$AI_FEATURES_ENABLED" = true ]; then
        return 0
    fi
    
    echo -e "\n${PURPLE}=== AI Assistance Available ===${NC}"
    echo -e "${YELLOW}This script includes AI-powered troubleshooting features.${NC}"
    echo -e "${BLUE}AI can help analyze network issues and suggest solutions.${NC}"
    echo -e ""
    
    if check_ai_availability >/dev/null 2>&1; then
        echo -e "${GREEN}AI services are available and ready to use.${NC}"
        echo -e "${YELLOW}Would you like to enable AI assistance? (y/N)${NC}"
        read -r response
        
        if [[ "$response" =~ ^[Yy]$ ]]; then
            AI_FEATURES_ENABLED=true
            echo -e "${GREEN}âœ“ AI features enabled for this session${NC}"
        else
            echo -e "${YELLOW}AI features disabled. You can enable them with --ai-enabled${NC}"
        fi
    else
        echo -e "${YELLOW}AI services not configured. Use --ai-help for setup instructions.${NC}"
    fi
}

# ============================================================================
# END AI MODULE
# ============================================================================

# ============================================================================
# COMMAND LINE ARGUMENT PARSING
# ============================================================================

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --ai-enabled)
            AI_FEATURES_ENABLED=true
            echo -e "${GREEN}âœ“ AI features enabled${NC}"
            shift
            ;;
        --color-profile)
            if [ -n "$2" ]; then
                set_color_profile "$2"
                COLOR_PROFILE_SET=true
                shift 2
            else
                echo -e "${RED}Error: Color profile name required${NC}"
                exit 1
            fi
            ;;
        --log-file)
            LOGGING_ENABLED=true
            LOG_FILE_SET=true
            if [ -n "$2" ] && [[ "$2" != --* ]]; then
                LOG_FILE="$2"                                    # Use user-provided name
                echo -e "${GREEN}âœ“ Logging enabled to: $LOG_FILE${NC}"
                shift 2
            else
                LOG_FILE="radico.LOG"                          # Default to radico.LOG
                echo -e "${GREEN}âœ“ Logging enabled to: $LOG_FILE (default)${NC}"
                shift
            fi
            ;;
        --ai-help)
            if [ -n "$2" ] && [ -n "$3" ]; then
                call_ai_api "$3" "$2"
                exit 0
            elif [ -n "$2" ]; then
                echo -e "${RED}Error: Query is required${NC}"
                echo -e "${YELLOW}Usage: $SCRIPT_NAME --ai-help SERVICE 'your query'${NC}"
                exit 1
            else
                show_ai_help
                exit 0
            fi
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            show_usage
            exit 1
            ;;
    esac
done

# ============================================================================
# MAIN EXECUTION FLOW
# ============================================================================

show_banner

# Offer color profile selection if not set via command line
if [ "$COLOR_PROFILE_SET" != true ]; then
    choose_color_profile
fi

# Setup logging if not configured via command line
if [ "$LOG_FILE_SET" != true ]; then
    echo -e "\n${CYAN}=== Logging Configuration ===${NC}"
    echo -e "${GREEN}âœ“ Logging is enabled by default for RADICO${NC}"
    echo -e "${BLUE}Current log file: $LOG_FILE${NC}"
    echo -e ""
    echo -e "${YELLOW}Options:${NC}"
    echo -e "1) Keep current settings (${LOG_FILE})"
    echo -e "2) Change log file name"
    echo -e "3) Disable logging for this session"
    echo -e ""
    echo -e "${BLUE}Choose option (1-3, default: 1): ${NC}"
    read -r log_choice
    
    case "${log_choice:-1}" in
        1)
            echo -e "${GREEN}âœ“ Using default logging to: $LOG_FILE${NC}"
            ;;
        2)
            echo -e "${BLUE}Enter new log file name: ${NC}"
            read -r custom_log_name
            if [ -n "$custom_log_name" ]; then
                LOG_FILE="$custom_log_name"
                echo -e "${GREEN}âœ“ Log file changed to: $LOG_FILE${NC}"
            else
                echo -e "${YELLOW}No name provided, keeping: $LOG_FILE${NC}"
            fi
            ;;
        3)
            LOGGING_ENABLED=false
            echo -e "${YELLOW}âš  Logging disabled for this session${NC}"
            ;;
        *)
            echo -e "${GREEN}âœ“ Using default logging to: $LOG_FILE${NC}"
            ;;
    esac
    
    if [ "$LOGGING_ENABLED" = true ]; then
        # Create log file with header
        {
            echo "========================================"
            echo "RADICO Connectivity Troubleshooter Log"
            echo "Started: $(date)"
            echo "OS: $OS $VERSION"
            echo "========================================"
        } > "$LOG_FILE"
        
        echo -e "${GREEN}âœ“ Logging active: $LOG_FILE${NC}"
        
        # Redirect all output to both console and log file
        exec > >(tee -a "$LOG_FILE")
        exec 2>&1
    fi
fi

echo -e "${BLUE}=== Connectivity Troubleshooter Tool Verification ===${NC}"

# Run tool verification
check_tools

# Prompt for AI features if not explicitly enabled
if [ "$AI_FEATURES_ENABLED" != true ]; then
    prompt_ai_features
fi

echo -e "\n${BLUE}=== Starting Connectivity Troubleshooting ===${NC}\n"

# Function to offer AI assistance if enabled
offer_ai_assistance() {
    local issue_type="$1"
    local issue_description="$2"
    
    if [ "$AI_FEATURES_ENABLED" = true ]; then
        echo -e "${PURPLE}ðŸ’¡ AI Suggestion: Use --ai-help for assistance with: $issue_type${NC}"
        echo -e "${CYAN}   Example: $SCRIPT_NAME --ai-help openai '$issue_description'${NC}"
    fi
}

# Enhanced connectivity troubleshooting sections with AI integration
run_ethernet_diagnostics() {
    echo -e "${CYAN}=== Ethernet Diagnostics ===${NC}"
    
    # Check if ethernet interface exists (both legacy and modern naming)
    if ! ip link show | grep -E "^[0-9]+: (eth[0-9]+|enp[0-9]+s[0-9]+|eno[0-9]+|ens[0-9]+)" >/dev/null 2>&1; then
        echo -e "${YELLOW}No ethernet interface found${NC}"
        offer_ai_assistance "Ethernet troubleshooting" "No ethernet interface detected on system"
        return 1
    fi
    
    # Basic interface status
    echo -e "${BLUE}Checking ethernet interfaces...${NC}"
    ip link show | grep -E "^[0-9]+: (eth[0-9]+|enp[0-9]+s[0-9]+|eno[0-9]+|ens[0-9]+)"
    
    # Check link status
    for iface in $(ip link show | grep -E "^[0-9]+: (eth[0-9]+|enp[0-9]+s[0-9]+|eno[0-9]+|ens[0-9]+)" | cut -d: -f2 | tr -d ' '); do
        echo -e "\n${BLUE}Checking $iface status...${NC}"
        if command_exists ethtool; then
            ethtool "$iface" | grep "Link detected"
        fi
        
        # Check if interface has IP
        if ! ip addr show "$iface" | grep -q "inet "; then
            echo -e "${YELLOW}âš  No IP address on $iface${NC}"
            offer_ai_assistance "Ethernet configuration" "$iface has no IP address assigned"
        fi
    done
}

run_wifi_diagnostics() {
    echo -e "${CYAN}=== WiFi Diagnostics ===${NC}"
    
    # Check for wireless interfaces (both legacy and modern naming)
    if ! ip link show | grep -E "^[0-9]+: (wlan[0-9]+|wlp[0-9]+s[0-9]+|wls[0-9]+|wlo[0-9]+)" >/dev/null 2>&1; then
        echo -e "${YELLOW}No wireless interface found${NC}"
        offer_ai_assistance "WiFi troubleshooting" "No wireless interface detected on system"
        return 1
    fi
    
    # Check if rfkill is blocking
    if command_exists rfkill; then
        echo -e "${BLUE}Checking rfkill status...${NC}"
        rfkill list all
        
        if rfkill list all | grep -q "Soft blocked: yes"; then
            echo -e "${RED}âš  Wireless is soft-blocked${NC}"
            offer_ai_assistance "WiFi rfkill issue" "Wireless interface is soft-blocked by rfkill"
        fi
    fi
    
    # Check wireless connection
    for iface in $(ip link show | grep -E "^[0-9]+: (wlan[0-9]+|wlp[0-9]+s[0-9]+|wls[0-9]+|wlo[0-9]+)" | cut -d: -f2 | tr -d ' '); do
        echo -e "\n${BLUE}Checking $iface status...${NC}"
        if command_exists iwconfig; then
            iwconfig "$iface"
        fi
        
        # Check if connected to network
        if command_exists iw; then
            if ! iw dev "$iface" link | grep -q "Connected"; then
                echo -e "${YELLOW}âš  $iface not connected to any network${NC}"
                offer_ai_assistance "WiFi connection" "$iface is not connected to any wireless network"
            fi
        fi
    done
}

run_bluetooth_diagnostics() {
    echo -e "${CYAN}=== Bluetooth Diagnostics ===${NC}"
    
    # Check if bluetooth is available
    if ! command_exists bluetoothctl; then
        echo -e "${RED}Bluetooth tools not available${NC}"
        offer_ai_assistance "Bluetooth setup" "Bluetooth tools are not installed on the system"
        return 1
    fi
    
    # Check bluetooth service
    echo -e "${BLUE}Checking bluetooth service...${NC}"
    systemctl status bluetooth --no-pager
    
    # Check bluetooth controller
    if command_exists hciconfig; then
        echo -e "\n${BLUE}Checking bluetooth controllers...${NC}"
        hciconfig -a
        
        if ! hciconfig | grep -q "UP RUNNING"; then
            echo -e "${YELLOW}âš  Bluetooth controller not active${NC}"
            offer_ai_assistance "Bluetooth controller" "Bluetooth controller is not in UP RUNNING state"
        fi
    fi
}

# Function to log messages
log_message() {
    local message="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    if [ "$LOGGING_ENABLED" = true ]; then
        echo "[$timestamp] $message" >> "$LOG_FILE"
    fi
}

# Enhanced output function that handles both display and logging
echo_log() {
    local message="$1"
    echo -e "$message"
    
    if [ "$LOGGING_ENABLED" = true ]; then
        # Strip ANSI color codes for log file
        local clean_message
        clean_message=$(echo -e "$message" | sed 's/\x1b\[[0-9;]*m//g')
        log_message "$clean_message"
    fi
}

# Main troubleshooting execution
run_comprehensive_diagnostics() {
    echo -e "${BLUE}=== Comprehensive Network Diagnostics ===${NC}"
    
    run_ethernet_diagnostics
    echo ""
    run_wifi_diagnostics  
    echo ""
    run_bluetooth_diagnostics
    
    if [ "$AI_FEATURES_ENABLED" = true ]; then
        echo -e "\n${PURPLE}=== AI Summary Available ===${NC}"
        echo -e "${YELLOW}Would you like an AI summary of all detected issues? (y/N)${NC}"
        read -r summary_response
        
        if [[ "$summary_response" =~ ^[Yy]$ ]]; then
            call_ai_api "Provide a summary and prioritized action plan for resolving network connectivity issues found during diagnostics" "openai"
        fi
    fi
}

# Function to generate connection status report
generate_connection_report() {
    echo -e "\n${CYAN}=== Connection Status Report ===${NC}"
    echo -e "${BLUE}Interface Status Summary:${NC}"
    echo -e ""
    
    # Check Ethernet interfaces (both legacy eth* and modern enp*, eno*, ens* naming)
    local eth_found=false
    for iface in $(ip link show 2>/dev/null | grep -E "^[0-9]+: (eth[0-9]+|enp[0-9]+s[0-9]+|eno[0-9]+|ens[0-9]+)" | cut -d: -f2 | tr -d ' '); do
        eth_found=true
        local status="disabled"
        local traffic="nil"
        
        # Check if interface is up
        if ip link show "$iface" 2>/dev/null | grep -q "state UP"; then
            status="enabled"
            
            # Check for IP address (indicates potential traffic capability)
            if ip addr show "$iface" 2>/dev/null | grep -q "inet "; then
                # Check for recent traffic via RX/TX stats
                local rx_bytes
                local tx_bytes
                rx_bytes=$(cat "/sys/class/net/$iface/statistics/rx_bytes" 2>/dev/null || echo "0")
                tx_bytes=$(cat "/sys/class/net/$iface/statistics/tx_bytes" 2>/dev/null || echo "0")
                
                if [ "$rx_bytes" -gt 1000 ] || [ "$tx_bytes" -gt 1000 ]; then
                    traffic="traffic"
                else
                    traffic="idle"
                fi
            else
                traffic="idle"
            fi
        fi
        
        echo -e "${YELLOW}ðŸ“¶ Ethernet ($iface):${NC} $status / $traffic"
    done
    
    if [ "$eth_found" = false ]; then
        echo -e "${YELLOW}ðŸ“¶ Ethernet:${NC} disabled / nil"
    fi
    
    # Check WiFi interfaces (both legacy wlan* and modern wlp*, wls*, wlo* naming)
    local wifi_found=false
    for iface in $(ip link show 2>/dev/null | grep -E "^[0-9]+: (wlan[0-9]+|wlp[0-9]+s[0-9]+|wls[0-9]+|wlo[0-9]+)" | cut -d: -f2 | tr -d ' '); do
        wifi_found=true
        local status="disabled"
        local traffic="nil"
        
        # Check if interface is up
        if ip link show "$iface" 2>/dev/null | grep -q "state UP"; then
            status="enabled"
            
            # Check if connected to network
            if command_exists iw && iw dev "$iface" link 2>/dev/null | grep -q "Connected"; then
                # Check for traffic
                local rx_bytes
                local tx_bytes
                rx_bytes=$(cat "/sys/class/net/$iface/statistics/rx_bytes" 2>/dev/null || echo "0")
                tx_bytes=$(cat "/sys/class/net/$iface/statistics/tx_bytes" 2>/dev/null || echo "0")
                
                if [ "$rx_bytes" -gt 1000 ] || [ "$tx_bytes" -gt 1000 ]; then
                    traffic="traffic"
                else
                    traffic="idle"
                fi
            else
                traffic="idle"
            fi
        fi
        
        echo -e "${YELLOW}ðŸ“¡ WiFi ($iface):${NC} $status / $traffic"
    done
    
    if [ "$wifi_found" = false ]; then
        echo -e "${YELLOW}ðŸ“¡ WiFi:${NC} disabled / nil"
    fi
    
    # Check Bluetooth
    local bt_status="disabled"
    local bt_traffic="nil"
    
    if command_exists hciconfig; then
        if hciconfig 2>/dev/null | grep -q "UP RUNNING"; then
            bt_status="enabled"
            
            # Check if any devices are connected
            if command_exists bluetoothctl; then
                if bluetoothctl devices Connected 2>/dev/null | grep -q "Device"; then
                    bt_traffic="traffic"
                else
                    bt_traffic="idle"
                fi
            else
                bt_traffic="idle"
            fi
        fi
    fi
    
    echo -e "${YELLOW}ðŸ”µ Bluetooth:${NC} $bt_status / $bt_traffic"
    
    # Check Loopback
    local lo_status="disabled"
    local lo_traffic="nil"
    
    if ip link show lo 2>/dev/null | grep -q "state UNKNOWN"; then
        lo_status="enabled"
        local rx_bytes
        rx_bytes=$(cat "/sys/class/net/lo/statistics/rx_bytes" 2>/dev/null || echo "0")
        if [ "$rx_bytes" -gt 0 ]; then
            lo_traffic="traffic"
        else
            lo_traffic="idle"
        fi
    fi
    
    echo -e "${YELLOW}ðŸ”„ Loopback:${NC} $lo_status / $lo_traffic"
    
    # Check for VPN interfaces
    local vpn_found=false
    for iface in $(ip link show 2>/dev/null | grep -E "(tun|tap|vpn)" | cut -d: -f2 | tr -d ' '); do
        vpn_found=true
        local status="disabled"
        local traffic="nil"
        
        if ip link show "$iface" 2>/dev/null | grep -q "state UNKNOWN\|state UP"; then
            status="enabled"
            local rx_bytes
            local tx_bytes
            rx_bytes=$(cat "/sys/class/net/$iface/statistics/rx_bytes" 2>/dev/null || echo "0")
            tx_bytes=$(cat "/sys/class/net/$iface/statistics/tx_bytes" 2>/dev/null || echo "0")
            
            if [ "$rx_bytes" -gt 0 ] || [ "$tx_bytes" -gt 0 ]; then
                traffic="traffic"
            else
                traffic="idle"
            fi
        fi
        
        echo -e "${YELLOW}ðŸ”’ VPN ($iface):${NC} $status / $traffic"
    done
    
    if [ "$vpn_found" = false ]; then
        echo -e "${YELLOW}ðŸ”’ VPN:${NC} disabled / nil"
    fi
    
    echo -e ""
    echo -e "${BLUE}Legend:${NC}"
    echo -e "  ${GREEN}enabled${NC}  - Interface is up and operational"
    echo -e "  ${RED}disabled${NC} - Interface is down or unavailable"
    echo -e "  ${GREEN}traffic${NC}  - Active data transmission detected"
    echo -e "  ${YELLOW}idle${NC}     - Interface ready but no significant traffic"
    echo -e "  ${RED}nil${NC}      - No connectivity or interface unavailable"
}

# Start comprehensive diagnostics
run_comprehensive_diagnostics

echo -e "\n${GREEN}=== Troubleshooting Complete ===${NC}"

# Show connection report when AI is not enabled
if [ "$AI_FEATURES_ENABLED" != true ]; then
    generate_connection_report
fi

if [ "$AI_FEATURES_ENABLED" = true ]; then
    echo -e "${PURPLE}ðŸ’¡ AI features were enabled for this session${NC}"
    echo -e "${CYAN}Use --ai-help SERVICE 'query' for specific AI assistance${NC}"
    echo -e "${YELLOW}ðŸ“– See NFO.md for comprehensive usage examples and documentation${NC}"
fi